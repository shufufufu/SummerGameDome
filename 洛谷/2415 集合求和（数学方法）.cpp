#include <bits/stdc++.h>  
using namespace std;  
  
int main() {  
    int a[1010], n = 0;  
    long long sum = 0;  
      
    // 读取整数，直到遇到换行符  
    do {  
        cin >> a[n];  
        n++;  
    } while (getchar() != '\n');  
      
    // 对于数组中的每个元素，计算它出现在多少个子集中，并累加到总和中  
    long long pow_two_n_minus_one = 1; // 2^(n-1)  
    for (int i = 1; i < n; i++) {  
        pow_two_n_minus_one *= 2; // 计算2的幂次  
    }  
      
    for (int i = 0; i < n; i++) {  
        sum += a[i] * pow_two_n_minus_one; // 将每个元素的贡献累加到总和中  
    }  
      
    // 输出总和  
    cout << sum << endl;  
      
    return 0;  
}

//要证明每个元素会出现在2^(n-1)个子集中，我们可以使用组合数学中的基本原理。
//
//考虑一个包含n个元素的数组，其中我们关注一个特定的元素x。为了形成一个子集，我们需要从剩余的n-1个元素中选择元素。每个这样的选择都会与元素x一起形成一个新的子集（包含x）或不形成一个新的子集（不包含x）。
//
//对于剩余的n-1个元素，我们可以选择0个、1个、2个，... ，直到n-1个来与元素x组合。因此，对于每个数量的选择（从0到n-1），都有C(n-1, k)种方式，其中k是我们从n-1个元素中选择的数量，C(n, k)表示从n个不同项中选取k个的组合数。
//
//现在，我们要计算所有可能的组合数，即所有k从0到n-1的C(n-1, k)的总和。根据组合数的性质，这个和等于2^(n-1)。这是因为每个元素（在n-1个元素中）都有两种状态：要么在子集中（用1表示），要么不在子集中（用0表示）。因此，总共有2^(n-1)种不同的组合方式。
//
//由于元素x可以与这2^(n-1)种组合中的每一种组合，因此元素x会出现在2^(n-1)个子集中。
//
//用数学表达式表示，对于数组中的任意元素x，它出现在子集中的次数是：
//Σ C(n-1, k)，其中k从0到n-1。
//这个和等于2^(n-1)，因此每个元素会出现在2^(n-1)个子集中。
//
//这个证明是基于组合数学的基本原理，特别是组合数的求和性质。它展示了为什么每个元素会出现在相同数量的子集中，这个数量就是2的(n-1)次方。